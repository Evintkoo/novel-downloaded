<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Novel to EPUB</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0b;
      --surface: #141416;
      --surface-2: #1c1c1f;
      --border: #2a2a2e;
      --text: #e4e4e7;
      --text-muted: #71717a;
      --accent: #a78bfa;
      --accent-dim: #7c3aed;
      --success: #34d399;
      --error: #f87171;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      width: 100%;
      max-width: 640px;
      padding: 0 20px;
    }

    header {
      text-align: center;
      padding: 60px 0 40px;
    }

    header h1 {
      font-size: 1.75rem;
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: 8px;
    }

    header p {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 16px;
    }

    .input-group {
      display: flex;
      gap: 10px;
    }

    .input-group input {
      flex: 1;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .input-group input::placeholder { color: var(--text-muted); }
    .input-group input:focus { border-color: var(--accent-dim); }

    .btn {
      background: var(--accent-dim);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
      white-space: nowrap;
    }

    .btn:hover { background: var(--accent); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .status {
      padding: 16px;
      border-radius: 8px;
      font-size: 0.85rem;
      display: none;
      margin-top: 16px;
      line-height: 1.6;
    }

    .status.show { display: block; }
    .status.info { background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.2); }
    .status.success { background: rgba(52, 211, 153, 0.1); border: 1px solid rgba(52, 211, 153, 0.2); }
    .status.error { background: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); }

    .progress-bar-container {
      margin-top: 12px;
      background: var(--surface-2);
      border-radius: 6px;
      height: 6px;
      overflow: hidden;
      display: none;
    }

    .progress-bar-container.show { display: block; }

    .progress-bar {
      height: 100%;
      background: var(--accent);
      border-radius: 6px;
      width: 0%;
      transition: width 0.3s;
    }

    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.2);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .library { margin-top: 8px; }

    .library h2 {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-muted);
    }

    .library-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 8px;
    }

    .library-item .info {
      flex: 1;
      min-width: 0;
    }

    .library-item .title {
      font-size: 0.85rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .library-item .meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .library-item .actions {
      display: flex;
      gap: 6px;
      margin-left: 12px;
      flex-shrink: 0;
    }

    .btn-sm {
      padding: 6px 14px;
      font-size: 0.78rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-weight: 500;
      transition: opacity 0.2s;
    }

    .btn-sm:hover { opacity: 0.85; }

    .btn-dl {
      background: var(--accent-dim);
      color: white;
    }

    .btn-del {
      background: transparent;
      color: var(--text-muted);
      border: 1px solid var(--border);
    }

    .btn-del:hover { color: var(--error); border-color: var(--error); }

    .library-empty {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.8rem;
      padding: 20px 0;
    }

    footer {
      text-align: center;
      padding: 40px 0;
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    footer a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Novel to EPUB</h1>
      <p>Paste a freewebnovel.com link and download the EPUB directly</p>
    </header>

    <div class="card">
      <div class="input-group">
        <input type="text" id="novel-url" placeholder="https://freewebnovel.com/novel/omegas-rebirth" onkeydown="if(event.key==='Enter')generate()">
        <button class="btn" id="gen-btn" onclick="generate()">Download</button>
      </div>
      <div class="status" id="status"></div>
      <div class="progress-bar-container" id="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
    </div>

    <div class="library" id="library"></div>
  </div>

  <footer>
    Built with <a href="https://github.com/Evintkoo/novel-downloaded" target="_blank">novel-downloaded</a>
  </footer>

  <script>
    // ── Library (IndexedDB for epub files, metadata for UI) ──
    const DB_NAME = 'novel-epub-store';
    const DB_VER = 1;
    const STORE = 'epubs';

    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = () => {
          if (!req.result.objectStoreNames.contains(STORE))
            req.result.createObjectStore(STORE, { keyPath: 'slug' });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function dbGet(slug) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const r = db.transaction(STORE).objectStore(STORE).get(slug);
        r.onsuccess = () => resolve(r.result || null);
        r.onerror = () => reject(r.error);
      });
    }

    async function dbPut(entry) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, 'readwrite');
        tx.objectStore(STORE).put(entry);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function dbDelete(slug) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, 'readwrite');
        tx.objectStore(STORE).delete(slug);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function dbAll() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const r = db.transaction(STORE).objectStore(STORE).getAll();
        r.onsuccess = () => resolve(r.result || []);
        r.onerror = () => reject(r.error);
      });
    }

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / 1048576).toFixed(1) + ' MB';
    }

    async function renderLibrary() {
      const el = document.getElementById('library');
      const items = await dbAll();
      if (items.length === 0) { el.innerHTML = ''; return; }
      items.sort((a, b) => b.savedAt - a.savedAt);
      el.innerHTML = '<h2>Downloaded</h2>' + items.map(item => {
        const safeSlug = escapeHtml(item.slug);
        return `<div class="library-item">
          <div class="info">
            <div class="title">${escapeHtml(item.title)}</div>
            <div class="meta">${escapeHtml(item.author)} · ${item.chapters} ch · ${formatSize(item.size)} · ${new Date(item.savedAt).toLocaleDateString()}</div>
          </div>
          <div class="actions">
            <button class="btn-sm btn-dl" data-slug="${safeSlug}" data-action="download">Download</button>
            <button class="btn-sm btn-del" data-slug="${safeSlug}" data-action="remove">Remove</button>
          </div>
        </div>`;
      }).join('');

      // Attach event listeners safely
      el.querySelectorAll('[data-action="download"]').forEach(btn => {
        btn.addEventListener('click', () => downloadSaved(btn.dataset.slug));
      });
      el.querySelectorAll('[data-action="remove"]').forEach(btn => {
        btn.addEventListener('click', () => removeSaved(btn.dataset.slug));
      });
    }

    async function downloadSaved(slug) {
      const entry = await dbGet(slug);
      if (!entry) return;
      const blob = new Blob([entry.epub], { type: 'application/epub+zip' });
      const safeTitle = entry.title.replace(/[<>:"/\\|?*]/g, '').trim();
      downloadBlob(blob, `${safeTitle}.epub`);
    }

    async function removeSaved(slug) {
      await dbDelete(slug);
      renderLibrary();
    }

    const PROXIES = [
      (u) => 'https://api.codetabs.com/v1/proxy/?quest=' + encodeURIComponent(u),
      (u) => 'https://api.allorigins.win/get?url=' + encodeURIComponent(u),
    ];
    const BASE = 'https://freewebnovel.com';
    const DELAY = 150;
    const WORKERS = 6;
    const FAIL = '__FAIL__';

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    function showStatus(msg, type) {
      const el = document.getElementById('status');
      el.innerHTML = msg;
      el.className = `status show ${type}`;
    }

    function setProgress(pct) {
      const c = document.getElementById('progress-container');
      const b = document.getElementById('progress-bar');
      c.classList.toggle('show', pct >= 0);
      b.style.width = Math.min(100, pct) + '%';
    }

    // Fetch via a specific proxy
    async function fetchVia(proxyFn, url, isJson) {
      const ac = new AbortController();
      const t = setTimeout(() => ac.abort(), 15000);
      try {
        const res = await fetch(proxyFn(url), { signal: ac.signal });
        clearTimeout(t);
        if (!res.ok) return null;
        if (isJson) {
          const json = await res.json();
          if (json.status?.http_code >= 400) return null;
          const contents = json.contents || null;
          if (contents && contents.length < 200) return null;
          return contents;
        }
        const text = await res.text();
        // Reject empty or very short proxy error pages
        if (!text || text.length < 200) return null;
        return text;
      } catch {
        clearTimeout(t);
        return null;
      }
    }

    // Try primary proxy (codetabs returns raw HTML), fallback to allorigins (JSON wrapper)
    async function fetchOnce(url) {
      const html = await fetchVia(PROXIES[0], url, false);
      if (html) return html;
      return await fetchVia(PROXIES[1], url, true);
    }

    // Fetch with retries
    async function fetchPage(url, retries = 0) {
      for (let i = 0; i <= retries; i++) {
        const html = await fetchOnce(url);
        if (html) return html;
        if (i < retries) await sleep(1500 * (i + 1));
      }
      return null;
    }

    function parseNovelDetail(html) {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const title = doc.querySelector('h1.tit')?.textContent.trim()
        || doc.querySelector('div.m-imgtxt h1')?.textContent.trim() || 'Unknown Title';

      const items = doc.querySelectorAll('div.m-imgtxt div.txt div.item');
      let author = 'Unknown Author';
      if (items.length > 0) {
        const right = items[0].querySelector('.right a') || items[0].querySelector('.right');
        if (right) author = right.textContent.trim();
      }

      const genres = [];
      if (items.length > 1) {
        items[1].querySelectorAll('.right a').forEach(a => genres.push(a.textContent.trim()));
      }

      const description = doc.querySelector('meta[name="description"]')?.content || '';
      const coverUrl = doc.querySelector('div.m-imgtxt div.pic img')?.src || '';

      const chapters = [];
      doc.querySelectorAll('ul#idData li a').forEach(a => {
        const chTitle = a.getAttribute('title') || a.textContent.trim();
        const href = a.getAttribute('href') || '';
        if (href) {
          chapters.push({
            title: chTitle,
            url: href.startsWith('http') ? href : BASE + href,
          });
        }
      });

      return { title, author, genres, description, coverUrl, chapters };
    }

    function parseChapterContent(html) {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const article = doc.querySelector('div#article');
      if (!article) return null;

      const chTitle = article.querySelector('h4')?.textContent.trim()
        || doc.querySelector('h1.tit')?.textContent.trim() || '';

      article.querySelectorAll('script, .ads, .ad, ins, .google-auto-placed').forEach(el => el.remove());

      const paragraphs = [];
      article.querySelectorAll('p').forEach(p => {
        const text = p.textContent.trim();
        if (text) paragraphs.push('<p>' + escapeXml(text) + '</p>');
      });

      if (paragraphs.length === 0) return null;

      return { title: chTitle, content: paragraphs.join('\n') };
    }

    function escapeXml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function escapeHtml(str) {
      const d = document.createElement('div');
      d.textContent = str || '';
      return d.innerHTML;
    }

    function buildEpub(novel, chapters) {
      const zip = new JSZip();

      zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });

      zip.file('META-INF/container.xml',
`<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`);

      zip.file('OEBPS/style.css',
`body { font-family: Georgia, serif; line-height: 1.8; margin: 1em; padding: 0; }
h1 { font-size: 1.4em; text-align: center; margin: 0 0 1.5em; padding-top: 2em; }
p { text-indent: 1.5em; margin: 0.5em 0; orphans: 3; widows: 3; }`);

      const manifest = [], spine = [], toc = [];

      for (let i = 0; i < chapters.length; i++) {
        const id = `ch${i + 1}`;
        const fn = `${id}.xhtml`;
        const ch = chapters[i];
        const t = escapeXml(ch.title || `Chapter ${i + 1}`);

        zip.file(`OEBPS/${fn}`,
`<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>${t}</title><link rel="stylesheet" href="style.css"/></head>
<body style="page-break-before:always; page-break-after:always;">
<h1>${t}</h1>
${ch.content || '<p>No content available.</p>'}
</body>
</html>`);

        manifest.push(`    <item id="${id}" href="${fn}" media-type="application/xhtml+xml"/>`);
        spine.push(`    <itemref idref="${id}"/>`);
        toc.push(`    <navPoint id="nav-${id}" playOrder="${i + 1}"><navLabel><text>${t}</text></navLabel><content src="${fn}"/></navPoint>`);
      }

      const st = escapeXml(novel.title);
      const sa = escapeXml(novel.author);
      const sd = escapeXml(novel.description);
      const uid = 'novel-' + Date.now();

      zip.file('OEBPS/content.opf',
`<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
    <dc:title>${st}</dc:title>
    <dc:creator opf:role="aut">${sa}</dc:creator>
    <dc:description>${sd}</dc:description>
    <dc:language>en</dc:language>
    <dc:identifier id="BookId">${uid}</dc:identifier>
${novel.genres.map(g => `    <dc:subject>${escapeXml(g)}</dc:subject>`).join('\n')}
  </metadata>
  <manifest>
    <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
    <item id="css" href="style.css" media-type="text/css"/>
${manifest.join('\n')}
  </manifest>
  <spine toc="ncx">
${spine.join('\n')}
  </spine>
</package>`);

      zip.file('OEBPS/toc.ncx',
`<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
  <head>
    <meta name="dtb:uid" content="${uid}"/>
    <meta name="dtb:depth" content="1"/>
    <meta name="dtb:totalPageCount" content="0"/>
    <meta name="dtb:maxPageNumber" content="0"/>
  </head>
  <docTitle><text>${st}</text></docTitle>
  <navMap>
${toc.join('\n')}
  </navMap>
</ncx>`);

      return zip.generateAsync({ type: 'blob', mimeType: 'application/epub+zip' });
    }

    function downloadBlob(blob, filename) {
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 10000);
    }

    // Download a single chapter (no retries by default)
    async function downloadChapter(ch, index, retries) {
      const html = await fetchPage(ch.url, retries);
      if (!html) return { title: ch.title || `Chapter ${index + 1}`, content: FAIL };
      const parsed = parseChapterContent(html);
      if (!parsed) return { title: ch.title || `Chapter ${index + 1}`, content: FAIL };
      return { title: parsed.title || ch.title, content: parsed.content };
    }

    async function generate() {
      const url = document.getElementById('novel-url').value.trim();
      const btn = document.getElementById('gen-btn');

      if (!url || !url.includes('freewebnovel.com')) {
        showStatus('Please enter a valid freewebnovel.com novel URL.', 'error');
        return;
      }

      btn.disabled = true;
      btn.innerHTML = '<span class="spinner"></span>Working...';
      setProgress(0);

      try {
        // Normalize URL
        let novelUrl = url;
        if (!novelUrl.startsWith('http')) novelUrl = 'https://' + novelUrl;
        const slugMatch = novelUrl.match(/freewebnovel\.com\/novel\/([^/\s?#]+)/);
        if (!slugMatch) throw new Error('Could not extract novel slug from URL.');
        const novelSlug = slugMatch[1];
        novelUrl = `${BASE}/novel/${novelSlug}`;

        // Check if already saved — download instantly
        const saved = await dbGet(novelSlug);
        if (saved) {
          const blob = new Blob([saved.epub], { type: 'application/epub+zip' });
          const safeTitle = saved.title.replace(/[<>:"/\\|?*]/g, '').trim();
          downloadBlob(blob, `${safeTitle}.epub`);
          setProgress(-1);
          showStatus(
            `<strong>${escapeHtml(saved.title)}</strong> — already saved, downloaded!`,
            'success'
          );
          btn.disabled = false;
          btn.textContent = 'Download';
          return;
        }

        // Step 1: Fetch novel detail (with 2 retries for the important detail page)
        showStatus('<span class="spinner"></span> Fetching novel details...', 'info');
        const detailHtml = await fetchPage(novelUrl, 2);
        if (!detailHtml) throw new Error('Failed to fetch novel details. Please try again.');
        const novel = parseNovelDetail(detailHtml);

        if (novel.chapters.length === 0) throw new Error('No chapters found for this novel.');

        const total = novel.chapters.length;
        const chapters = new Array(total);
        let done = 0;
        let next = 0;
        const startTime = Date.now();

        function updateUI() {
          const pct = (done / total) * 100;
          setProgress(pct);
          const elapsed = (Date.now() - startTime) / 1000;
          const rate = done / Math.max(elapsed, 1);
          const remaining = rate > 0 ? Math.ceil((total - done) / rate) : 0;
          const mins = Math.floor(remaining / 60);
          const secs = remaining % 60;
          const eta = done > 5 ? ` — ~${mins > 0 ? mins + 'm ' : ''}${secs}s left` : '';
          const failCount = chapters.filter(c => c && c.content === FAIL).length;

          showStatus(
            `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
            `${done} / ${total} chapters` +
            (failCount > 0 ? ` (${failCount} to retry)` : '') +
            eta,
            'info'
          );
        }

        updateUI();

        // Step 2: Fast first pass — no retries, workers never block on failures
        async function worker() {
          while (next < total) {
            const i = next++;
            const t0 = Date.now();
            chapters[i] = await downloadChapter(novel.chapters[i], i, 0);
            done++;
            updateUI();
            const elapsed = Date.now() - t0;
            const wait = DELAY - elapsed;
            if (wait > 0 && next < total) await sleep(wait);
          }
        }

        const workers = [];
        for (let w = 0; w < WORKERS; w++) {
          workers.push(worker());
          if (w < WORKERS - 1) await sleep(DELAY / 2);
        }
        await Promise.all(workers);

        // Step 3: Retry failed chapters — up to 3 passes with increasing retries
        for (let pass = 1; pass <= 3; pass++) {
          const failedIdxs = [];
          for (let i = 0; i < total; i++) {
            if (chapters[i].content === FAIL) failedIdxs.push(i);
          }
          if (failedIdxs.length === 0) break;

          showStatus(
            `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
            `Retry pass ${pass}/3 — ${failedIdxs.length} chapters to recover...`,
            'info'
          );

          // Wait before retry pass
          await sleep(2000 * pass);

          for (let r = 0; r < failedIdxs.length; r++) {
            const i = failedIdxs[r];
            chapters[i] = await downloadChapter(novel.chapters[i], i, pass);
            showStatus(
              `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
              `Retry pass ${pass}/3: ${r + 1} / ${failedIdxs.length}`,
              'info'
            );
            await sleep(800);
          }
        }

        // Mark any still-failed chapters
        let finalFailed = 0;
        for (let i = 0; i < total; i++) {
          if (chapters[i].content === FAIL) {
            chapters[i].content = '<p>[Chapter unavailable]</p>';
            finalFailed++;
          }
        }

        // Step 4: Build EPUB
        showStatus('<span class="spinner"></span> Building EPUB...', 'info');
        const blob = await buildEpub(novel, chapters);

        // Step 5: Save to storage and download
        const epubBuffer = await blob.arrayBuffer();
        await dbPut({
          slug: novelSlug,
          title: novel.title,
          author: novel.author,
          chapters: total,
          size: epubBuffer.byteLength,
          savedAt: Date.now(),
          epub: epubBuffer,
        });
        renderLibrary();

        const safeTitle = novel.title.replace(/[<>:"/\\|?*]/g, '').trim();
        downloadBlob(blob, `${safeTitle}.epub`);

        setProgress(-1);
        showStatus(
          `<strong>${escapeHtml(novel.title)}</strong> — ${total} chapters` +
          (finalFailed ? ` (${finalFailed} unavailable)` : '') +
          `<br>EPUB saved and downloaded!`,
          'success'
        );

      } catch (err) {
        setProgress(-1);
        showStatus(`Error: ${escapeHtml(err.message)}`, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = 'Download';
      }
    }

    // Auto-import pre-built EPUBs from manifest into IndexedDB
    async function syncFromManifest() {
      try {
        const res = await fetch('epubs/manifest.json');
        if (!res.ok) return;
        const manifest = await res.json();

        for (const item of manifest) {
          const existing = await dbGet(item.slug);
          if (existing) continue;

          // Fetch the epub file and store it
          const epubRes = await fetch(`epubs/${item.file}`);
          if (!epubRes.ok) continue;
          const epub = await epubRes.arrayBuffer();

          await dbPut({
            slug: item.slug,
            title: item.title,
            author: item.author,
            chapters: item.chapters,
            size: epub.byteLength,
            savedAt: Date.now(),
            epub,
          });
        }
      } catch (err) {
        console.warn('syncFromManifest failed:', err.message || err);
      }
      renderLibrary();
    }

    // Load library on page init
    syncFromManifest();
  </script>
</body>
</html>
