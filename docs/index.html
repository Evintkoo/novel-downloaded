<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Novel to EPUB</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0b;
      --surface: #141416;
      --surface-2: #1c1c1f;
      --border: #2a2a2e;
      --text: #e4e4e7;
      --text-muted: #71717a;
      --accent: #a78bfa;
      --accent-dim: #7c3aed;
      --success: #34d399;
      --error: #f87171;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      width: 100%;
      max-width: 640px;
      padding: 0 20px;
    }

    header {
      text-align: center;
      padding: 60px 0 40px;
    }

    header h1 {
      font-size: 1.75rem;
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: 8px;
    }

    header p {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 16px;
    }

    .input-group {
      display: flex;
      gap: 10px;
    }

    .input-group input {
      flex: 1;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .input-group input::placeholder { color: var(--text-muted); }
    .input-group input:focus { border-color: var(--accent-dim); }

    .btn {
      background: var(--accent-dim);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
      white-space: nowrap;
    }

    .btn:hover { background: var(--accent); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .status {
      padding: 16px;
      border-radius: 8px;
      font-size: 0.85rem;
      display: none;
      margin-top: 16px;
      line-height: 1.6;
    }

    .status.show { display: block; }
    .status.info { background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.2); }
    .status.success { background: rgba(52, 211, 153, 0.1); border: 1px solid rgba(52, 211, 153, 0.2); }
    .status.error { background: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); }

    .progress-bar-container {
      margin-top: 12px;
      background: var(--surface-2);
      border-radius: 6px;
      height: 6px;
      overflow: hidden;
      display: none;
    }

    .progress-bar-container.show { display: block; }

    .progress-bar {
      height: 100%;
      background: var(--accent);
      border-radius: 6px;
      width: 0%;
      transition: width 0.3s;
    }

    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.2);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    footer {
      text-align: center;
      padding: 40px 0;
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    footer a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Novel to EPUB</h1>
      <p>Paste a freewebnovel.com link and download the EPUB directly</p>
    </header>

    <div class="card">
      <div class="input-group">
        <input type="text" id="novel-url" placeholder="https://freewebnovel.com/novel/omegas-rebirth" onkeydown="if(event.key==='Enter')generate()">
        <button class="btn" id="gen-btn" onclick="generate()">Download</button>
      </div>
      <div class="status" id="status"></div>
      <div class="progress-bar-container" id="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
    </div>
  </div>

  <footer>
    Built with <a href="https://github.com/Evintkoo/novel-downloaded" target="_blank">novel-downloaded</a>
  </footer>

  <script>
    // Use /get endpoint — always returns 200 JSON, avoids CORS issues on 5xx
    const PROXY = (u) => 'https://api.allorigins.win/get?url=' + encodeURIComponent(u);
    const BASE = 'https://freewebnovel.com';
    const DELAY_PER_WORKER = 600;  // ms between requests per worker
    const WORKER_COUNT = 2;        // 2 staggered workers
    const MAX_RETRIES = 3;         // retries per request
    const FAIL = '__FAIL__';

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    function showStatus(msg, type) {
      const el = document.getElementById('status');
      el.innerHTML = msg;
      el.className = `status show ${type}`;
    }

    function setProgress(pct) {
      const c = document.getElementById('progress-container');
      const b = document.getElementById('progress-bar');
      c.classList.toggle('show', pct >= 0);
      b.style.width = Math.min(100, pct) + '%';
    }

    // Single fetch via allorigins /get (JSON wrapper, always 200)
    async function rawFetch(url, timeoutMs = 20000) {
      const ac = new AbortController();
      const t = setTimeout(() => ac.abort(), timeoutMs);
      try {
        const res = await fetch(PROXY(url), { signal: ac.signal });
        clearTimeout(t);
        if (!res.ok) throw new Error(`Proxy error ${res.status}`);
        const json = await res.json();
        // allorigins returns { contents, status: { http_code } }
        const code = json.status?.http_code;
        if (code && code >= 400) throw new Error(`HTTP ${code}`);
        if (!json.contents) throw new Error('Empty response');
        return json.contents;
      } catch (err) {
        clearTimeout(t);
        throw err.name === 'AbortError' ? new Error('Timeout') : err;
      }
    }

    // Fetch with retries + short backoff
    async function fetchPage(url) {
      for (let i = 0; i <= MAX_RETRIES; i++) {
        try {
          return await rawFetch(url);
        } catch (err) {
          if (i === MAX_RETRIES) throw err;
          // Short backoff: 1.5s, 3s, 4.5s
          await sleep(1500 * (i + 1));
        }
      }
    }

    function parseNovelDetail(html) {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const title = doc.querySelector('h1.tit')?.textContent.trim()
        || doc.querySelector('div.m-imgtxt h1')?.textContent.trim() || 'Unknown Title';

      const items = doc.querySelectorAll('div.m-imgtxt div.txt div.item');
      let author = 'Unknown Author';
      if (items.length > 0) {
        const right = items[0].querySelector('.right a') || items[0].querySelector('.right');
        if (right) author = right.textContent.trim();
      }

      const genres = [];
      if (items.length > 1) {
        items[1].querySelectorAll('.right a').forEach(a => genres.push(a.textContent.trim()));
      }

      const description = doc.querySelector('meta[name="description"]')?.content || '';
      const coverUrl = doc.querySelector('div.m-imgtxt div.pic img')?.src || '';

      const chapters = [];
      doc.querySelectorAll('ul#idData li a').forEach(a => {
        const chTitle = a.getAttribute('title') || a.textContent.trim();
        const href = a.getAttribute('href') || '';
        if (href) {
          chapters.push({
            title: chTitle,
            url: href.startsWith('http') ? href : BASE + href,
          });
        }
      });

      return { title, author, genres, description, coverUrl, chapters };
    }

    function parseChapterContent(html) {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const article = doc.querySelector('div#article');
      if (!article) return { title: '', content: '<p>No content found.</p>' };

      const chTitle = article.querySelector('h4')?.textContent.trim()
        || doc.querySelector('h1.tit')?.textContent.trim() || '';

      article.querySelectorAll('script, .ads, .ad, ins, .google-auto-placed').forEach(el => el.remove());

      const paragraphs = [];
      article.querySelectorAll('p').forEach(p => {
        const text = p.textContent.trim();
        if (text) paragraphs.push('<p>' + escapeXml(text) + '</p>');
      });

      return { title: chTitle, content: paragraphs.join('\n') };
    }

    function escapeXml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function escapeHtml(str) {
      const d = document.createElement('div');
      d.textContent = str || '';
      return d.innerHTML;
    }

    function buildEpub(novel, chapters) {
      const zip = new JSZip();

      zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });

      zip.file('META-INF/container.xml',
`<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`);

      zip.file('OEBPS/style.css',
`body { font-family: Georgia, serif; line-height: 1.8; margin: 1em; padding: 0; }
h1 { font-size: 1.4em; text-align: center; margin: 0 0 1.5em; padding-top: 2em; }
p { text-indent: 1.5em; margin: 0.5em 0; orphans: 3; widows: 3; }`);

      const manifest = [], spine = [], toc = [];

      for (let i = 0; i < chapters.length; i++) {
        const id = `ch${i + 1}`;
        const fn = `${id}.xhtml`;
        const ch = chapters[i];
        const t = escapeXml(ch.title || `Chapter ${i + 1}`);

        zip.file(`OEBPS/${fn}`,
`<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>${t}</title><link rel="stylesheet" href="style.css"/></head>
<body style="page-break-before:always; page-break-after:always;">
<h1>${t}</h1>
${ch.content || '<p>No content available.</p>'}
</body>
</html>`);

        manifest.push(`    <item id="${id}" href="${fn}" media-type="application/xhtml+xml"/>`);
        spine.push(`    <itemref idref="${id}"/>`);
        toc.push(`    <navPoint id="nav-${id}" playOrder="${i + 1}"><navLabel><text>${t}</text></navLabel><content src="${fn}"/></navPoint>`);
      }

      const st = escapeXml(novel.title);
      const sa = escapeXml(novel.author);
      const sd = escapeXml(novel.description);
      const uid = 'novel-' + Date.now();

      zip.file('OEBPS/content.opf',
`<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
    <dc:title>${st}</dc:title>
    <dc:creator opf:role="aut">${sa}</dc:creator>
    <dc:description>${sd}</dc:description>
    <dc:language>en</dc:language>
    <dc:identifier id="BookId">${uid}</dc:identifier>
${novel.genres.map(g => `    <dc:subject>${escapeXml(g)}</dc:subject>`).join('\n')}
  </metadata>
  <manifest>
    <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
    <item id="css" href="style.css" media-type="text/css"/>
${manifest.join('\n')}
  </manifest>
  <spine toc="ncx">
${spine.join('\n')}
  </spine>
</package>`);

      zip.file('OEBPS/toc.ncx',
`<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
  <head>
    <meta name="dtb:uid" content="${uid}"/>
    <meta name="dtb:depth" content="1"/>
    <meta name="dtb:totalPageCount" content="0"/>
    <meta name="dtb:maxPageNumber" content="0"/>
  </head>
  <docTitle><text>${st}</text></docTitle>
  <navMap>
${toc.join('\n')}
  </navMap>
</ncx>`);

      return zip.generateAsync({ type: 'blob', mimeType: 'application/epub+zip' });
    }

    function downloadBlob(blob, filename) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    }

    // Download a single chapter with retries, returns result object
    async function downloadChapter(ch, index) {
      try {
        const html = await fetchPage(ch.url);
        const parsed = parseChapterContent(html);
        return { title: parsed.title || ch.title, content: parsed.content };
      } catch {
        return { title: ch.title || `Chapter ${index + 1}`, content: FAIL };
      }
    }

    async function generate() {
      const url = document.getElementById('novel-url').value.trim();
      const btn = document.getElementById('gen-btn');

      if (!url || !url.includes('freewebnovel.com')) {
        showStatus('Please enter a valid freewebnovel.com novel URL.', 'error');
        return;
      }

      btn.disabled = true;
      btn.innerHTML = '<span class="spinner"></span>Working...';
      setProgress(0);

      try {
        // Normalize URL
        let novelUrl = url;
        if (!novelUrl.startsWith('http')) novelUrl = 'https://' + novelUrl;
        const slugMatch = novelUrl.match(/freewebnovel\.com\/novel\/([^/\s?#]+)/);
        if (!slugMatch) throw new Error('Could not extract novel slug from URL.');
        novelUrl = `${BASE}/novel/${slugMatch[1]}`;

        // Step 1: Fetch novel detail
        showStatus('<span class="spinner"></span> Fetching novel details...', 'info');
        const detailHtml = await fetchPage(novelUrl);
        const novel = parseNovelDetail(detailHtml);

        if (novel.chapters.length === 0) throw new Error('No chapters found for this novel.');

        const total = novel.chapters.length;
        const chapters = new Array(total);
        let done = 0;
        let next = 0;
        const startTime = Date.now();

        function updateUI() {
          const pct = (done / total) * 100;
          setProgress(pct);
          const elapsed = (Date.now() - startTime) / 1000;
          const rate = done / Math.max(elapsed, 1);
          const remaining = rate > 0 ? Math.ceil((total - done) / rate) : 0;
          const mins = Math.floor(remaining / 60);
          const secs = remaining % 60;
          const eta = done > 5 ? ` — ~${mins > 0 ? mins + 'm ' : ''}${secs}s left` : '';
          const failCount = chapters.filter(c => c && c.content === FAIL).length;

          showStatus(
            `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
            `${done} / ${total} chapters` +
            (failCount > 0 ? ` (${failCount} to retry)` : '') +
            eta,
            'info'
          );
        }

        updateUI();

        // Step 2: Download with 2 staggered workers
        async function worker() {
          while (next < total) {
            const i = next++;
            const t0 = Date.now();
            chapters[i] = await downloadChapter(novel.chapters[i], i);
            done++;
            updateUI();
            // Enforce minimum delay per worker
            const elapsed = Date.now() - t0;
            const wait = DELAY_PER_WORKER - elapsed;
            if (wait > 0 && next < total) await sleep(wait);
          }
        }

        // Stagger worker starts by half the interval
        const workers = [];
        for (let w = 0; w < WORKER_COUNT; w++) {
          workers.push(worker());
          if (w < WORKER_COUNT - 1) await sleep(DELAY_PER_WORKER / 2);
        }
        await Promise.all(workers);

        // Step 3: Retry all failures — up to 3 full retry passes
        for (let pass = 1; pass <= 3; pass++) {
          const failedIdxs = [];
          for (let i = 0; i < total; i++) {
            if (chapters[i].content === FAIL) failedIdxs.push(i);
          }
          if (failedIdxs.length === 0) break;

          showStatus(
            `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
            `Retry pass ${pass}/3 — ${failedIdxs.length} chapters to recover...`,
            'info'
          );

          // Wait before retry pass to let server recover
          await sleep(3000 * pass);

          for (let r = 0; r < failedIdxs.length; r++) {
            const i = failedIdxs[r];
            chapters[i] = await downloadChapter(novel.chapters[i], i);
            showStatus(
              `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
              `Retry pass ${pass}/3: ${r + 1} / ${failedIdxs.length}`,
              'info'
            );
            // Slower pace for retries
            await sleep(1200);
          }
        }

        // Mark any still-failed chapters
        let finalFailed = 0;
        for (let i = 0; i < total; i++) {
          if (chapters[i].content === FAIL) {
            chapters[i].content = '<p>[Chapter unavailable]</p>';
            finalFailed++;
          }
        }

        // Step 4: Build EPUB
        showStatus('<span class="spinner"></span> Building EPUB...', 'info');
        const blob = await buildEpub(novel, chapters);

        // Step 5: Download
        const safeTitle = novel.title.replace(/[<>:"/\\|?*]/g, '').trim();
        downloadBlob(blob, `${safeTitle}.epub`);

        setProgress(-1);
        showStatus(
          `<strong>${escapeHtml(novel.title)}</strong> — ${total} chapters` +
          (finalFailed ? ` (${finalFailed} unavailable)` : '') +
          `<br>EPUB downloaded!`,
          'success'
        );

      } catch (err) {
        setProgress(-1);
        showStatus(`Error: ${escapeHtml(err.message)}`, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = 'Download';
      }
    }
  </script>
</body>
</html>
