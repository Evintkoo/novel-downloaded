<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Novel to EPUB</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0b;
      --surface: #141416;
      --surface-2: #1c1c1f;
      --border: #2a2a2e;
      --text: #e4e4e7;
      --text-muted: #71717a;
      --accent: #a78bfa;
      --accent-dim: #7c3aed;
      --success: #34d399;
      --error: #f87171;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      width: 100%;
      max-width: 640px;
      padding: 0 20px;
    }

    header {
      text-align: center;
      padding: 60px 0 40px;
    }

    header h1 {
      font-size: 1.75rem;
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: 8px;
    }

    header p {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 16px;
    }

    .input-group {
      display: flex;
      gap: 10px;
    }

    .input-group input {
      flex: 1;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .input-group input::placeholder { color: var(--text-muted); }
    .input-group input:focus { border-color: var(--accent-dim); }

    .btn {
      background: var(--accent-dim);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
      white-space: nowrap;
    }

    .btn:hover { background: var(--accent); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .status {
      padding: 16px;
      border-radius: 8px;
      font-size: 0.85rem;
      display: none;
      margin-top: 16px;
      line-height: 1.6;
    }

    .status.show { display: block; }
    .status.info { background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.2); }
    .status.success { background: rgba(52, 211, 153, 0.1); border: 1px solid rgba(52, 211, 153, 0.2); }
    .status.error { background: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); }

    .progress-bar-container {
      margin-top: 12px;
      background: var(--surface-2);
      border-radius: 6px;
      height: 6px;
      overflow: hidden;
      display: none;
    }

    .progress-bar-container.show { display: block; }

    .progress-bar {
      height: 100%;
      background: var(--accent);
      border-radius: 6px;
      width: 0%;
      transition: width 0.3s;
    }

    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.2);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    footer {
      text-align: center;
      padding: 40px 0;
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    footer a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Novel to EPUB</h1>
      <p>Paste a freewebnovel.com link and download the EPUB directly</p>
    </header>

    <div class="card">
      <div class="input-group">
        <input type="text" id="novel-url" placeholder="https://freewebnovel.com/novel/omegas-rebirth" onkeydown="if(event.key==='Enter')generate()">
        <button class="btn" id="gen-btn" onclick="generate()">Download</button>
      </div>
      <div class="status" id="status"></div>
      <div class="progress-bar-container" id="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
    </div>
  </div>

  <footer>
    Built with <a href="https://github.com/Evintkoo/novel-downloaded" target="_blank">novel-downloaded</a>
  </footer>

  <script>
    const PROXY_FNS = [
      (u) => 'https://api.allorigins.win/raw?url=' + encodeURIComponent(u),
      (u) => 'https://corsproxy.io/?' + encodeURIComponent(u),
    ];
    const BASE = 'https://freewebnovel.com';

    function showStatus(msg, type) {
      const el = document.getElementById('status');
      el.innerHTML = msg;
      el.className = `status show ${type}`;
    }

    function setProgress(pct) {
      const container = document.getElementById('progress-container');
      const bar = document.getElementById('progress-bar');
      container.classList.toggle('show', pct >= 0);
      bar.style.width = Math.min(100, pct) + '%';
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function fetchPage(url) {
      const MAX_RETRIES = 4;
      for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
        for (const proxy of PROXY_FNS) {
          try {
            const res = await fetch(proxy(url));
            if (res.status === 429) {
              // Rate limited — back off exponentially
              const wait = Math.min(1000 * Math.pow(2, attempt), 8000);
              await sleep(wait);
              break; // retry from outer loop
            }
            if (!res.ok) continue; // try next proxy
            return await res.text();
          } catch (err) {
            continue; // try next proxy
          }
        }
        // If we exhausted proxies on this attempt, wait before retrying
        if (attempt < MAX_RETRIES) await sleep(500 * (attempt + 1));
      }
      throw new Error(`Failed after ${MAX_RETRIES + 1} attempts: ${url}`);
    }

    function parseNovelDetail(html) {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const title = doc.querySelector('h1.tit')?.textContent.trim()
        || doc.querySelector('div.m-imgtxt h1')?.textContent.trim() || 'Unknown Title';

      const items = doc.querySelectorAll('div.m-imgtxt div.txt div.item');
      let author = 'Unknown Author';
      if (items.length > 0) {
        const right = items[0].querySelector('.right a') || items[0].querySelector('.right');
        if (right) author = right.textContent.trim();
      }

      const genres = [];
      if (items.length > 1) {
        items[1].querySelectorAll('.right a').forEach(a => genres.push(a.textContent.trim()));
      }

      const description = doc.querySelector('meta[name="description"]')?.content || '';
      const coverUrl = doc.querySelector('div.m-imgtxt div.pic img')?.src || '';

      const chapters = [];
      doc.querySelectorAll('ul#idData li a').forEach(a => {
        const chTitle = a.getAttribute('title') || a.textContent.trim();
        const href = a.getAttribute('href') || '';
        if (href) {
          chapters.push({
            title: chTitle,
            url: href.startsWith('http') ? href : BASE + href,
          });
        }
      });

      return { title, author, genres, description, coverUrl, chapters };
    }

    function parseChapterContent(html) {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const article = doc.querySelector('div#article');
      if (!article) return { title: '', content: '<p>No content found.</p>' };

      const chTitle = article.querySelector('h4')?.textContent.trim()
        || doc.querySelector('h1.tit')?.textContent.trim() || '';

      article.querySelectorAll('script, .ads, .ad, ins, .google-auto-placed').forEach(el => el.remove());

      const paragraphs = [];
      article.querySelectorAll('p').forEach(p => {
        const text = p.textContent.trim();
        if (text) paragraphs.push('<p>' + escapeXml(text) + '</p>');
      });

      return { title: chTitle, content: paragraphs.join('\n') };
    }

    function escapeXml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str || '';
      return div.innerHTML;
    }

    function buildEpub(novel, chapters) {
      const zip = new JSZip();

      // mimetype must be first and uncompressed
      zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });

      // container.xml
      zip.file('META-INF/container.xml',
`<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`);

      // style.css — each chapter file is its own page, no mid-chapter breaks
      zip.file('OEBPS/style.css',
`body { font-family: Georgia, serif; line-height: 1.8; margin: 1em; padding: 0; }
h1 { font-size: 1.4em; text-align: center; margin: 0 0 1.5em; padding-top: 2em; }
p { text-indent: 1.5em; margin: 0.5em 0; orphans: 3; widows: 3; }`);

      // chapter xhtml files
      const manifest = [];
      const spine = [];
      const toc = [];

      for (let i = 0; i < chapters.length; i++) {
        const id = `ch${i + 1}`;
        const filename = `${id}.xhtml`;
        const ch = chapters[i];
        const chTitle = escapeXml(ch.title || `Chapter ${i + 1}`);

        zip.file(`OEBPS/${filename}`,
`<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>${chTitle}</title><link rel="stylesheet" href="style.css"/></head>
<body style="page-break-before:always; page-break-after:always;">
<h1>${chTitle}</h1>
${ch.content || '<p>No content available.</p>'}
</body>
</html>`);

        manifest.push(`    <item id="${id}" href="${filename}" media-type="application/xhtml+xml"/>`);
        spine.push(`    <itemref idref="${id}"/>`);
        toc.push(`    <navPoint id="nav-${id}" playOrder="${i + 1}"><navLabel><text>${chTitle}</text></navLabel><content src="${filename}"/></navPoint>`);
      }

      // content.opf
      const safeTitle = escapeXml(novel.title);
      const safeAuthor = escapeXml(novel.author);
      const safeDesc = escapeXml(novel.description);
      const uid = 'novel-' + Date.now();

      zip.file('OEBPS/content.opf',
`<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
    <dc:title>${safeTitle}</dc:title>
    <dc:creator opf:role="aut">${safeAuthor}</dc:creator>
    <dc:description>${safeDesc}</dc:description>
    <dc:language>en</dc:language>
    <dc:identifier id="BookId">${uid}</dc:identifier>
${novel.genres.map(g => `    <dc:subject>${escapeXml(g)}</dc:subject>`).join('\n')}
  </metadata>
  <manifest>
    <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
    <item id="css" href="style.css" media-type="text/css"/>
${manifest.join('\n')}
  </manifest>
  <spine toc="ncx">
${spine.join('\n')}
  </spine>
</package>`);

      // toc.ncx
      zip.file('OEBPS/toc.ncx',
`<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
  <head>
    <meta name="dtb:uid" content="${uid}"/>
    <meta name="dtb:depth" content="1"/>
    <meta name="dtb:totalPageCount" content="0"/>
    <meta name="dtb:maxPageNumber" content="0"/>
  </head>
  <docTitle><text>${safeTitle}</text></docTitle>
  <navMap>
${toc.join('\n')}
  </navMap>
</ncx>`);

      return zip.generateAsync({ type: 'blob', mimeType: 'application/epub+zip' });
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    const CONCURRENCY = 4;
    const FAIL_MARKER = '__FAILED__';

    async function runPool(items, concurrency, fn, onProgress) {
      const results = new Array(items.length);
      let next = 0;
      let done = 0;

      async function worker() {
        while (next < items.length) {
          const i = next++;
          results[i] = await fn(items[i], i);
          done++;
          if (onProgress) onProgress(done, items.length);
        }
      }

      await Promise.all(
        Array.from({ length: Math.min(concurrency, items.length) }, () => worker())
      );
      return results;
    }

    async function generate() {
      const url = document.getElementById('novel-url').value.trim();
      const btn = document.getElementById('gen-btn');

      if (!url || !url.includes('freewebnovel.com')) {
        showStatus('Please enter a valid freewebnovel.com novel URL.', 'error');
        return;
      }

      btn.disabled = true;
      btn.innerHTML = '<span class="spinner"></span>Working...';
      setProgress(0);

      try {
        // Normalize URL
        let novelUrl = url;
        if (!novelUrl.startsWith('http')) novelUrl = 'https://' + novelUrl;
        const slugMatch = novelUrl.match(/freewebnovel\.com\/novel\/([^/\s?#]+)/);
        if (!slugMatch) throw new Error('Could not extract novel slug from URL.');
        novelUrl = `${BASE}/novel/${slugMatch[1]}`;

        // Step 1: Fetch novel detail
        showStatus('<span class="spinner"></span> Fetching novel details...', 'info');
        const detailHtml = await fetchPage(novelUrl);
        const novel = parseNovelDetail(detailHtml);

        if (novel.chapters.length === 0) throw new Error('No chapters found for this novel.');

        const total = novel.chapters.length;

        showStatus(
          `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong> by ${escapeHtml(novel.author)}<br>` +
          `Downloading ${total} chapters...`,
          'info'
        );

        // Step 2: First pass — download all chapters with concurrency
        const chapters = await runPool(novel.chapters, CONCURRENCY, async (ch, i) => {
          try {
            const chHtml = await fetchPage(ch.url);
            const parsed = parseChapterContent(chHtml);
            return { title: parsed.title || ch.title, content: parsed.content };
          } catch {
            return { title: ch.title || `Chapter ${i + 1}`, content: FAIL_MARKER, url: ch.url };
          }
        }, (done) => {
          setProgress((done / total) * 100);
          const failCount = chapters ? chapters.filter(c => c && c.content === FAIL_MARKER).length : 0;
          showStatus(
            `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
            `Downloaded ${done} / ${total} chapters` + (failCount ? ` (retrying ${failCount} later)` : ''),
            'info'
          );
        });

        // Step 3: Retry pass — re-fetch failed chapters one at a time with longer backoff
        const failedIdxs = chapters.map((c, i) => c.content === FAIL_MARKER ? i : -1).filter(i => i >= 0);
        if (failedIdxs.length > 0) {
          showStatus(
            `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
            `Retrying ${failedIdxs.length} failed chapters...`,
            'info'
          );

          for (let r = 0; r < failedIdxs.length; r++) {
            const i = failedIdxs[r];
            const ch = novel.chapters[i];
            // Wait a bit between retries to let rate limits reset
            if (r > 0) await sleep(1500);
            try {
              const chHtml = await fetchPage(ch.url);
              const parsed = parseChapterContent(chHtml);
              chapters[i] = { title: parsed.title || ch.title, content: parsed.content };
            } catch {
              chapters[i] = { title: ch.title || `Chapter ${i + 1}`, content: '<p>[Chapter unavailable]</p>' };
            }
            showStatus(
              `<span class="spinner"></span> <strong>${escapeHtml(novel.title)}</strong><br>` +
              `Retrying failed chapters: ${r + 1} / ${failedIdxs.length}`,
              'info'
            );
          }
        }

        const finalFailed = chapters.filter(c => c.content === '<p>[Chapter unavailable]</p>').length;

        // Step 4: Build EPUB
        showStatus('<span class="spinner"></span> Building EPUB...', 'info');
        const blob = await buildEpub(novel, chapters);

        // Step 5: Download
        const safeTitle = novel.title.replace(/[<>:"/\\|?*]/g, '').trim();
        downloadBlob(blob, `${safeTitle}.epub`);

        setProgress(-1);
        showStatus(
          `<strong>${escapeHtml(novel.title)}</strong> — ${total} chapters` +
          (finalFailed ? ` (${finalFailed} unavailable)` : '') + `<br>EPUB downloaded!`,
          'success'
        );

      } catch (err) {
        setProgress(-1);
        showStatus(`Error: ${escapeHtml(err.message)}`, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = 'Download';
      }
    }
  </script>
</body>
</html>
